// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "first.h"
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/PlatformThreadFactory.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/protocol/TJSONProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>


#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/PlatformThreadFactory.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TSocket.h>
#include <thrift/transport/TTransportUtils.h>
#include <thrift/TToString.h>
#include <boost/make_shared.hpp>
#include <iostream>
using namespace std;
using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace apache::thrift::concurrency;

using boost::shared_ptr;

class firstHandler : virtual public firstIf {
 public:
  firstHandler() {
    // Your initialization goes here
  }

  void ping() {
    // Your implementation goes here
    printf("ping\n");
  }

  int64_t add(const int64_t x, const int64_t y) {
    // Your implementation goes here
    return x + y;
    printf("add\n");
  }

  void connect(std::string& _return, const std::string& first, const std::string& second) {
    // Your implementation goes here
    _return = first + second;
    printf("connect\n");
  }

  void structure(rsp_struct& _return, const req_struct& req) {
    _return.uid = req.uid;
    _return.total = 0;
    for (auto i : req.nums) {
        printf("i: %d\n", i);
        _return.total += i;
    }
    printf("structure uid: %lld, nickname: %s, size: %u, total: %d\n", 
            req.uid, req.nickname.c_str(), req.nums.size(), _return.total);
  }

};

class firstCloneFactory : virtual public firstIfFactory {
public:
    virtual ~firstCloneFactory() {}
    virtual firstIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) {
        boost::shared_ptr<TSocket> sock = boost::dynamic_pointer_cast<TSocket>(connInfo.transport);
        cout << "Incoming connection\n";
        cout << "\tSocketInfo: "  << sock->getSocketInfo() << "\n";
        cout << "\tPeerHost: "    << sock->getPeerHost() << "\n";
        cout << "\tPeerAddress: " << sock->getPeerAddress() << "\n";
        cout << "\tPeerPort: "    << sock->getPeerPort() << "\n";
        return new firstHandler;
    }
    virtual void releaseHandler(firstIf* handler ) {
        delete handler;
    }
};

int main(int argc, char **argv) {
  int port = 9090;
//  shared_ptr<firstHandler> handler(new firstHandler());
//  shared_ptr<TProcessor> processor(new firstProcessor(handler));
//  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
//  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
//  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
  //shared_ptr<TProtocolFactory> protocolFactory(new TJSONProtocolFactory());


  /*
  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  */

    const int workerCount = 32;
    boost::shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(workerCount);
    threadManager->threadFactory(boost::make_shared<PlatformThreadFactory>());
    threadManager->start();

// This server allows "workerCount" connection at a time, and reuses threads
    TThreadPoolServer server(boost::make_shared<firstProcessorFactory>(boost::make_shared<firstCloneFactory>()), 
            boost::make_shared<TServerSocket>(9090), 
            boost::make_shared<TBufferedTransportFactory>(), 
            boost::make_shared<TBinaryProtocolFactory>(), 
            threadManager);
  server.serve();
  return 0;
}

